
###  Packages  -------------------
# _______________________________________________________________________

cat("\n 
    Global Option Settings: \n
    Not transform string to factor when load data \n
    Not use NA in any calculation \n
    Only print 4 ts. \n 
    
    Print Warnings as they occure \n")

options(stringsAsFactors = FALSE, na.rm=T,warn=1)


# Pakcages we will use:
cat("\n")
list.of.packages <- 
  c(
    
    # visualization
    "ggplot2","scales",
    
    # regular expression
    "stringr", 
    
    # data maniputaltion
    "reshape","reshape2","data.table","plyr","dplyr","magrittr","DataCombine",
    
    # some functions in dplyr are duplicate in plyr, and we want to use functions in dplyr 
    # so load plyr first and then let dplyr to mask it.
    
    # panel and cross sectional data 
    "plm","AER","censReg",
    
    # machine learning and Bayesian
    # "nnet",
    
    # time series
    "lubridate", "zoo","tseries", 
    
    # statistics and regression
    "VGAM","MASS","Formula", 
    
    # excel files
    "readxl",
    # "XML","XLConnect",
    
    # literature programming & code style
    "knitr","formatR",'yaml', 'htmltools', 'caTools','rmarkdown',"xtable",
    
    # Computing on the Language
    "pryr", "gtools","lazyeval"
    
  )

cat("Pakcages we will use : \n")
print(list.of.packages)


cat("\n \n check new packages that this computer did not install before \n")

new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]

cat("\n \n download & install new packages \n")

if(length(new.packages)) install.packages(new.packages)


# _____________________________________________________________

cat("\n \n load packages to R \n")
for (Library in list.of.packages) library(Library,character.only = T)


# ggplot2 default font size
theme_set(theme_gray(base_size = 18))


###  Quick Functions  -------------------
# _______________________________________________________________________


if (!exists("print.data.frame2")){ # only load these they are not defined
  # only print data for the first 200 rows
  
  print.data.frame2=print.data.frame
  print.data.frame=function(x){
    y=min(nrow(x),200 )
    print.data.frame2(x[1:y,,drop = F]) # use drop = F option to keep the data.frame class
  }
}
# print(data.frame(1:4))
# use drop = F option to keep the data.frame class
# x = data.frame(1:4)
# x[1:3,]
# x[1:3,,drop = F]





Enter_to_Continue=function(Pairs_data.frame = NA){
  # from attach_load_first.R
  # Type words in keyboard, return certain values, and then continue
  # Enter_to_Continue when you are in thr process of runing code
  
  # Pairs_data.frame shall be a two column data.frame, with first column as what you want to type,
  # second column as what you want to return
  # an example would be: Pairs_data.frame = rbind(c('small','small data'),c('n','normal'),c('w','weird curve'))
  Return=NA
  
  cat ("\n .... Press [enter] to continue; Type [s] to stop ....")
  
  if (!is.null(Pairs_data.frame) && !is.na(Pairs_data.frame) &&
      nrow(Pairs_data.frame)>0){
    for (pair_row in 1:nrow(Pairs_data.frame)) {
      # pair = List[[1]]
      cat("\n .... Type [ ",paste(Pairs_data.frame[pair_row,1])," ]"," to return '",
          paste(Pairs_data.frame[pair_row,2]),"' as object 'Return' ....",sep='')
    }
  }
  
  
  line <- readline()
  if (line=='s' | line=='S') stop("Stop ! ")
  
  
  # line = 'small'
  if (!is.null(Pairs_data.frame) && !is.na(Pairs_data.frame) &&
      nrow(Pairs_data.frame)>0 ) {
    
    Match = match(line,paste(Pairs_data.frame[,1]))
    Return = Pairs_data.frame[Match,2]
  }
  Return
  
  # unit test code: 
  # Enter_to_Continue(rbind(c('small','small data'),c('n','normal'),c('w','weird curve')))
  
  
}

equal =  function(x,y) {
  # an attach_Load_First.R function
  
  # USED to replace == to when compare two numeric values
  # a lot times two numeric values are not the same in R
  # example
  # 3.3/3 == 1.1
  
  # so this function can do the comparision correctly.
  
  return(mapply(function(x, y) {isTRUE(all.equal(x, y))}, a, b))
  if(F){
    22.1 == (22.2 -0.1)
    equal(22.1, 22.2 -0.1)
  }
}


###  Time Functions  -------------------
# _______________________________________________________________________



month_end_delta= function(month_end,delta){
  # from attach_load_first.R
  
  # similar as db2date in sas
  
  #delta=12
  #month_end=201205
  YEAR=floor(month_end/100)
  MONTH=month_end-YEAR*100
  YEAR_delta=floor((MONTH+delta)/12)
  
  Replace=which(
    floor((MONTH+delta)/12)==(MONTH+delta)/12
  )
  YEAR_delta[Replace]=YEAR_delta[Replace]-1
  MONTH_delta=MONTH+delta-YEAR_delta*12
  #print(YEAR_delta)
  #print(MONTH_delta)
  YEAR*100+YEAR_delta*100+MONTH_delta
  
  # UNIT TEST::   month_end_delta(201401,-3)
  
}


as_Date_month_end=function(x = econ[,"mnemonic."] ,Format="%Y%m%d"){ # transfor month end to standard date format in R
  # from attach_load_first.R
  
  
  as.Date(paste(x,"01",sep=''),Format)
  # UNIT TEST::  as_Date_month_end(x=201404)
  
}


as_month_end=function(x,Numeric=F){
  # from attach_load_first.R
  
  # transfor date to month_end
  
  y= year(x)*100+month(x)
  if (Numeric) y= year(x)*12+month(x)
  y
}


month_end_diff = function(start=201101,end=201202){
  # from attach_load_first.R
  
  floor(end/100) * 12 - floor(start/100) * 12  +
    ( end - floor(end/100)*100) - (start - floor(start/100)*100)
  
  # UNIT TEST::  
  # as_Date_month_end(x=201404)
  # month_end_diff(201102,201203)
  
}


stand_Q = function(x,Q_character = NULL){
  # an attach_Load_First.R function
  # return Q from  string like this c("x 4Qq","TEDSF 1Qq")
  
  # Q_character = 'Q'
  
  Q = rep(NA,length(x))
  x = tolower(x)
  for (i in c(1:4)){
    # i = 1
    Q[str_detect(x,paste(i,tolower(Q_character),sep=''))] = i
  }
  return(as.numeric(Q))
  
  if (F){
    
    stand_Q(c("x 4Qq","TEDSF 1Qq"))
    
  }
}



stand_Y= function(x,Year_Range = c(c(2000:2018)),year_digits = 4){
  # an attach_Load_First.R function
  # return the year t from the string that contain years
  
  # year_digits: if in the string, the standard year format is 2 digits, then put year_digits = 2.
  
  
  Y = rep(NA,length(x))
  
  if (year_digits ==4 & max(str_length(Year_Range)) ==2){
    Year_Range = paste(20,Year_Range)
  }
  
  if (year_digits ==2 & max(str_length(Year_Range)) ==4){
    Year_Range = str_replace(Year_Range,'20','')
  }
  
  for (i in Year_Range){
    Y[str_detect(x,paste(i))] = i
  }
  
  return(as.numeric(Y))
  
  if(F){
    stand_Y(c("qeqwe 2004","fwef2007"))
    
    stand_Y(c("qeqwe 04","fwef07"),paste(0,1:9,sep=''))
    
  }
}



as.Date.q = function(a,position_q = 6){
  # an attach_Load_First.R function
  
  # make a standardized quarter string as date
  #   > as.Date.q(a = "2014 4q")
  #   [1] "2014-11-01"
  
  a_Q = substr(a, position_q,position_q)%>% as.numeric 
  a_Y = substr(a, 1,4) %>% as.numeric
  
  month = a_Q *3 -1
  return(as.Date(paste(a_Y,month,"01",sep="-")))
  
  if (F){
    as.Date.q(a = "2014 4q") 
  }
}



diff_q = function(a,b,position_q = 6 ){
  # an attach_Load_First.R function
  
  # difference in Q between a and b: if b is later than a, 
  # then shall return a positive number
  
  # for example 2011 4q has Q infor in the 6th digit 
  
  
  a_Q = substr(a, position_q,position_q) %>% as.numeric
  b_Q = substr(b, position_q,position_q) %>% as.numeric
  a_Y = substr(a, 1,4) %>% as.numeric
  b_Y = substr(b, 1,4) %>% as.numeric
  
  # One difference year is 4q difference
  return(
    (b_Y - a_Y)*4 + b_Q - a_Q
  )
  
  # unit test
  if (F){
    
    diff_q(a = 2011.4,b = 2015.3)
    diff_q(a = 2011.4,b = 2015.4)
    
    diff_q(a = "2015 3Q" ,b = "2011 4Q",position_q = 6)
    diff_q(a = "20153Q" ,b = "20114Q",position_q = 5)
    
    diff_q(a = 2015.3 ,b = 2011.4)
    diff_q(a = 2015.4 ,b = 2011.4)
    
  }
  
}




change_q = function(q,
                    delta = 0, # numeric, the change of q
                    position_q = 6, # position_q means the position of Q infor in the string: 
                    # for example 2011 4q has Q infor in the 6th digit 
                    character = T # whether to return a standard character format 
){
  # an attach_Load_First.R function
  
  # Let the quarter data move delta quarter forward or backward
  
  # q =c("2015.4",NA)
  
  #   > change_q( q= 2011.4,delta = 13)
  #   [1] "2015 1Q"
  
  a_Q = substr(q, position_q,position_q) %>% as.numeric
  a_Y = substr(q, 1,4) %>% as.numeric
  
  q = a_Q/10 + a_Y
  # transform the YYYYQ data into YYYY.Q as numeric
  result = q + 
    delta%/%4 + #y
    delta%%4/10  # q
  
  result = as.numeric(result)
  
  for (i in 1:length(result)){
    # i=1
    
    if (!is.na(result[i]) && (result[i] > floor(result[i]) + 0.4) ){ 
      result[i] =  result[i] - (floor(result[i]) + 0.4) + floor(result[i]) + 1
    }
    
    #     if (!is.na(result[i]) && result[i] <= floor(result[i])){
    #       result[i] =  result[i] - floor(result[i]) + 0.4 + floor(result[i]) - 1
    #     }
    
  }
  
  for (i in 1:length(result)){
    if (!is.na(result[i]) && character){
      a_Q = substr(result[i], 6,6)
      a_Y = substr(result[i], 1,4)
      result[i] = paste(a_Y," ",a_Q,"Q",sep='')
    }
  }
  
  
  return(result)
  
  if (F){
    change_q( q= 2011.4,delta = 13)
    change_q( q= 2011.4,delta = 13,character = F)
    
    change_q( q= "2011 4Q",delta = 13,character = F)
    change_q( q= "2011 4Q",delta = 13)
    
    
    change_q( q= 2011.4,delta = -1)
    change_q( q= 2011.4,delta = 1)
    change_q( q= 2011.4,delta = 4)
    
    change_q( q= 2011.4,delta = -5)
    change_q( q= 2011.4,delta = -9)
    
    change_q( q= c(2011.4,2014.3),delta = -9)
    change_q( q= c(2011.4,2014.3,NA),delta = -9)
    
  }
}


###  Algebra Functions  -------------------
# _______________________________________________________________________



Mode <- function(x) {
  # from attach_load_first.R
  # get mode number from a numeric vector  
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

is.increase = function(x){
  # to check whether the vector is increasing
  all(x == cummax(x))
} 
is.decrease = function(x){
  # to check whether the vector is increasing
  all(x == cummin(x))
} 
# is.increase(1:10)
# is.increase(c(2,4,3)) # wrong

# is.decrease(10:1)


asc <- function(x) { 
  # from attach_load_first.R
  
  # convert ASCII code to integers according to ASCII chart
  strtoi(charToRaw(x),16L) 
} 


lowest_numeric = function(x, N = 2, method = "position", 
                          align = c("left","right","centered","all"),
                          second.lowest = F ){
  
  # an attach_Load_First.R function
  
  # return the position / sum / mean of lowest N rolling elements
  align = match.arg(align)
  
  roll_mean = rollmean(x,k = N)
  names(roll_mean) = 1:length(roll_mean)
  
  extreme_position = which.min(roll_mean)
  
  if (second.lowest) {
    extreme_2 = min(roll_mean[-extreme_position])
    extreme_position = which(roll_mean == extreme_2)
  }
  
  extreme_position = extreme_position:(extreme_position+N-1)
  
  if ( method == 'position'){
    if (align == 'right') y = max(extreme_position)
    if (align == 'left') y = min(extreme_position)
    if (align == 'all') y = extreme_position
  }
  
  if (method == 'sum'){
    y = sum(x[extreme_position],na.rm=T)
  }
  if (method == 'mean'){
    y = mean(x[extreme_position],na.rm=T)
  }
  
  return(y)
  
  if (F) {
    set.seed(1)
    x = runif(10)
    x
    lowest_numeric(x)
    lowest_numeric(c(1,2,-10,4,-20,4324))
    lowest_numeric(c(1,2,-10,4,-20,4324),3)
    lowest_numeric(c(1,2,-10,4,-20,4324),4)
    
    lowest_numeric(c(1,2,-10,4,-20,4324),2,"sum")
    lowest_numeric(c(1,2,-10,4,-20,4324),3,"sum")
    lowest_numeric(c(1,2,-10,4,-20,4324),4,"sum")
    
    lowest_numeric(x = c(1,2,-10,4,-20,4324),N = 2,align = 'left',method = "position")
    lowest_numeric(x = c(1,2,-10,4,-20,4324),N = 2,align = 'all',method = "position")
    lowest_numeric(x = c(1,2,-10,4,-20,4324),N = 2,align = 'right',method = "position")
    
    lowest_numeric(c(1,2,-10,4,-20,4324),2,"mean")
    lowest_numeric(c(1,2,-10,4,-20,4324),2,"sum")
    
    lowest_numeric(c(1,2,-10,4,-20,4324),3,"mean")
    lowest_numeric(c(1,2,-10,4,-20,4324),4,"mean")
  }
}


###  Data Manipulation Functions  -------------------
# _______________________________________________________________________



Join = function(x, y, by = NULL, type = "left", match = "all",
                duplicate = c("delete","add","copy"), PRINT=T, 
                constraint.x = NULL,
                constraint.y = NULL
                # UPDATE
){
  # from attach_load_first.R
  # this function is based on "join" (small cap !!) from dplyr.
  # To understand the join function, please enter ?join
  
  # Look out: when joined keys are numerics, note that R use floarting points so numeric looks the same will not equal!
  # like 22.1 == 22.2-0.1 is not TRUE.
  # so better to use factor or character.
  
  # _________ match __________
  # how should duplicate ids be matched? Either match just the "first" matching row, or match "all" matching rows. 
  # Defaults to "all" for compatibility with merge and SQL, but "first" is significantly faster.
  # Default will give you the same behavior as SQL join does
  
  # _______ by ________           
  # a character vector of variables to join by. If NULL, the default, join will do a natural join, using all variables 
  # with common names across the two tables. A message lists the variables so that you can check they're right.
  # To join by different variables on x and y use a named vector. 
  #   For example, by = c("a" = "b") will match x.a to y.b.
  # 
  
  
  # ______ duplicate________ # it add functionalities about how to deal with duplicated variables 
  
  # 'delete' means to delete all duplicated variables except the first one. This is the default option
  # NULL means doing nothing, so duplicated variables will be kept.
  # 'add' means duplicated variables will be added up if it is numeric, or combined if it is character.
  # 'mix' means duplicated varables will be k
  
  
  # If an element in "by" vector has its name attribute, 
  # such as by = c("id_x"="id_y"), then we mean to match id_x in x with id_y in y
  # to achive this, we will  
    # 1.change the "id_y" in y to "id_x"
    # 2.change the value "id_y" in the "by" vector to "id_x"
  
  
  duplicate = match.arg(duplicate)
  
  if (is.null(by)) {
    by =  intersect(colnames(x),colnames(y))
    message("BY the join index as: ",paste(by,collapese =' '))
  }

  if ( !is.null(by) && 
       (str_length(names(by)) > 0) %>% sum # has at least one name 
  ){
    
    place_name = str_length(names(by)) > 0 # which element has name?
    
    by_with_name = by [place_name] # select those elements with name
    
    for ( i in 1:length(by_with_name)){ 
      # i =1
      
      #1  change the names in y to id_x
      colnames(y)[which(colnames(y) == by_with_name[i])] =  names(by_with_name[i])
      # head(x2) ;  head(x) ; head(expand_data)
    }
    
    #2 change the value in "by" from id id_y
    by[place_name] = names(by)[place_name]
    
  }
  #   join(x =x2, y = y, by = by)
  
  
  # only observations in x that meet constraint.x can be matched
  
  
  if (!is.null(constraint.x)){
    x[,"constraint.x"] = subset2_(df = x,condition = constraint.x, position = T)
    y[,"constraint.x"] = 1
    by = c(by,"constraint.x")
  }
  
  if (!is.null(constraint.y)){
    y[,"constraint.y"] = subset2_(df = y,condition = constraint.y, position = T)
    x[,"constraint.y"] = 1
    by = c(by,"constraint.y")
    
  }
  
  
  test = plyr::join(x =x, y = y, by = by, type = type, match = match)
  
  test = deletenames(test,c("constraint.x","constraint.x"))

  
  #______ deal with duplicated names __________
  
  # identify the duplicated names
  dup_names = colnames(test)[duplicated(colnames(test))]
  
  if (PRINT && length(dup_names)){
    message("\n duplicated column names generated: ", paste(dup_names,collapse = ' '),"\n")  
  }
  
  if (length(duplicate) && length(dup_names)) { 
    
    Names = colnames(test)
    to_be_deleted =NULL
    
    for ( i in dup_names){
      # i = dup_names[1]
      
      dup_position = which( Names %in% i)
      
      # if numeric, then add them up
      if (duplicate =='add' && class(test[,dup_position[1]]) %in% c('numeric','integer')  ) {
        test[,dup_position[1]] = rowSums(test[,dup_position],na.rm=T)
      }
      
      # if character, then collapse them
      if (duplicate =='add' && class(test[,dup_position[1]]) %in% c('character')  ) {
        test[,dup_position[1]] =apply(test[,dup_position],1,paste,collapse='  ') 
      }
      
      if (duplicate =='copy'){
        NA_position = is.na(test[,dup_position[1]]) |  is.null(test[,dup_position[1]])
        test[NA_position,dup_position[1]] = test[NA_position,dup_position[2]]
      }

      # only leave the first duplicated column.
      
      # accumulate the to_be_deleted 
      to_be_deleted = c(to_be_deleted,dup_position[-1] # -1 means the last element
                        )
    }
    test = test[,-to_be_deleted]
  }
  return(test)
  
  if (F){
    
    
    ## UNIT TEST Code : 
    
    Table1 = data.frame(A =c('x','y','z'),B = c(1:3), C=c(11:13))
    Table2 = Table1
    Table2[,2:3] = -Table2[,2:3]
    
    Join (x= Table1,y = Table2,by = c('A'),type = 'left',duplicate = 'add')
    Join (Table1,Table2,by = c('A'),type = 'left',duplicate = 'delete')
    Join (Table1,Table2,by = c('A'),type = 'left',duplicate = NULL)
    
    
    # get the first year of each team
    first <- ddply(baseball, "id", summarise, first = min(year))
    
    setnames(first,"id","ide_1")
    
    head(baseball)
    
    head(first)
    
    #  join when names in x and y are different
    Join(x = baseball, y = first, by = c("id"="ide_1"))
    
    # join only when the team's name is 'RC1' in x
    Join(x = baseball, y = first, by = c("id"="ide_1"),constraint.x = c('team' = 'RC1')) %>% head
    
    
  }
  
}


setnames.copy = function(x, old_keys= old_keys, new_keys = new_keys, PRINT = T){
  
  # from attach_load_first.R
  
  # change names of variables. 
    # similar as setnames, but setnames is to change names without copy the data,
    # here we force to copy the data, and generate a new dataset, and then change the names on the new dataset, 
  
  # x = actual
  for (i in 1:length(old_keys)){
    position = colnames(x) == old_keys[i]
    
    if (position %>% sum){
      if (PRINT) message(paste("Name Changed:",old_keys[i],"change to", new_keys[i]))
      colnames(x)[position] = new_keys[i]
    } else {
      if (PRINT) message(paste("CANNOT find any colname matched with",old_keys[i])) 
    }
  }
  return(x)
  
  
  if(F){
    
    head(diamonds)
    setnames.copy(diamonds,"carat","Carat") %>% head
    setnames.copy(diamonds,"Carat","carat") %>% head
    
  }
}

deletenames = function(x, 
                       to_be_delete = NULL, # vars to be deleted 
                       fuzzy = F, # whether to use fuzzy match, see example
                       PRINT = F
                       ){
  
  # from attach_load_first.R
    # output the dataset after delete certain vars
  
  
  
  # x = test
  # to_be_delete =c("constraint.x","constraint.x")
  
  if (fuzzy) {
    postion = str_detect(colnames(x) ,to_be_delete)
    y = x[,!postion]
  } else {
    postion = colnames(x) %in% to_be_delete
    y = x[,!postion]
  }
  
  # if x contains duplcated names, then those duplicated names will be changed in y
  # so this step will just replace names in y with the original names in x
  colnames(y) = colnames(x)[!postion]
  
  if (PRINT && sum(postion)){ 
    message(
      paste(colnames(x)[postion],collapse=', ')," :  deleted"
    )
  }
  return(y)
  
  if (F) { 
    diamonds %>% head
    deletenames(diamonds %>% head,to_be_delete = c("pric","cut"))
    deletenames(diamonds %>% head,to_be_delete = c("pric","cu"),fuzzy = T)
  }
    
}

subset2_ <- function(df, condition,position = F) {
  
  # from attach_load_first.R
  
  # lazy evaluation version of subset.
  # conditions can be formula or string
  # from: https://github.com/hadley/lazyeval/blob/master/vignettes/lazyeval.Rmd
  
  r <- lazy_eval(condition, df)
  r <- r & !is.na(r)
  
  if ( position ) { result = r 
  } else {
    result = df[r, , drop = FALSE]
  }
  
  return(result)
  
  
  if (F) { 
    subset2_(mtcars, ~mpg > 31)
    subset2_(mtcars, quote(mpg > 31))
    subset2_(mtcars, "mpg > 31") 
    subset2_(mtcars, "mpg > 31",position = T) 
    subset2_(df = diamonds, condition = "color == 'E'")
  }
} 



subset_multiple = function(df, condtion_v = NULL,  # multiple conditions in the format of string
                           position = F){
  
  # from attach_load_first.R
  
  # similar as subset, but can apply multiple conditions (in the string format) at the same time
  # depend on subset2_

  
  if (is.null(condtion_v) || is.na(condtion_v) ) {
    message("condtions contain NULL or NAs, original dataset is returned.")
    return(df)
  }
  
  if ( sum(condtion_v %in% c("data.frame" ,"matrix"))){
    condtion_v = condtion_v[1,]
  }
  
  
  sanity_check(condtion_v,fuzzy_match = df)
  
  
  Subset = 0 
  condtion_full = paste(condtion_v,collapse = ") & (") %>% paste("(",.,")")
  Subset = subset2_(df,condtion_full,position = T) 
  
  
  if (position) {
    return(Subset)
  } else {
    df_result = df[Subset,]
    return(data.frame(df_result, condtion_full))
  }
  
  
  if (F){
    subset_multiple(df) %>% nrow(.) == nrow(df) # no condidtion applied
    subset_multiple(df = diamonds, condtion_v = c(price = "price>=500",color = "color == 'E'"))
    subset_multiple(df = diamonds, condtion_v = c(price = "price>=500",color = "color == 'E'"),position = T)
  }
  
}


var_to_value = function(x, sep = ' == ',left = '(',right = ')',Colnames = NULL){
  
  # for a data.frame, combine the colnames and their corresponding values together
  # see example
  
  x = unique.comb(diamonds,index = c('price   >    1000',"cut"))
  x = x[,index]
  
  colnames(x) = paste(left,colnames(x),right,sep='')
  for (i in 1:ncol(x)){
    if (sum(class(x[,i]) %in% c("character","factor"))){
      x[,i] = paste("'",x[,i],"'",sep='')
    }
    x[,i] =  paste(left,colnames(x)[i],"==",x[,i],right)
  }
  if (!is.null(Colnames)) colnames(x) = Colnames

  return(x)
  
  if(F){
    unique.comb(diamonds,index = c('price   >    1000',"cut")) %>% var_to_value()
  }
   
}
  
subsetN_ = function(df, condtion_v = NULL,  # multiple conditions in the format of string
                    value # value of those conditions, if the condition is just a var, then here it shall be the value of the var
                    # if the condition is an T/F statement, then the corresponding value shall be T or F.
                    
){
  
  # from attach_load_first.R
  
  # similar as subset, but can apply multiple conditions (in the string format) at the same time
  # depend on subset2_
  
  if (is.null(condtion_v)) return(df)
  
  sanity_check(condtion_v, exact_length = length(value))
  
  # i = 1 
  if (class(value) %in% c("data.frame","matrix")) {
    value = value %>% as.list
  }
  
  # i = 2
  Subset = 0 
  
  for (i in 1:length(condtion_v)){ 
    target = value [[i]]
    if (sum(class(target) %in% c("character","factor"))) target = paste("'",target,"'",sep='')
    Subset = subset2_(df, paste("(",condtion_v[i],")","==",target),position = T) + Subset
  }
  
  return(df[Subset >= length(condtion_v),])
  
  if (F){
    subsetN_(df = diamonds,
             condtion_v = c(price = "price>=500",color = "color"),
             value = list(T,'E'))
    
    # data.frame(t(condtion_v))
  }
  
}


unique.comb = function(x, # data
                       index = NULL, # index: can be vars, or conditions. must be in the format of character. 
                       unique_var = NA 
                       # one of the vars, used to decide whether the index vars can identify unique values of that var 
                       # see example            
                       ){
  # from attach_load_first.R
  
  # used to generate unique combinations of index
  
  if (is.null(index)){
    index = colnames(x)
  } else {
    # see whether can match the colnames in x
    sanity_check(index,fuzzy_match = x)
  }
  
  index = unique(index)
  
  if (is.na(unique_var)){
    # head(x)
    result = x %>% 
      group_by_(.dots = index) %>%
      summarise_(n = ~n()) %>% data.frame
    
  } else {
    result = x %>% 
      filter_(paste("!is.na(",unique_var,")")) %>% 
      group_by_(.dots =index) %>%
      summarise_(n = ~n(),
                 unique = paste("n_distinct(",unique_var,")")) %>% 
      data.frame
    
    if(sum(result$n != result$unique)){
      warning("there are non unique values in the combination") 
    }
    
  }
  
  colnames(result)[1:length(index)] = index
  
  return(result)
  
  
  if (F){
    
    unique.comb(diamonds,index = c('price>1000',"cut")) %>% head
    unique.comb(diamonds,index = c('price>1000',"cut"),unique_var = 'color') %>% head
    unique.comb(diamonds,index = c('color',"cut"),unique = 'price') %>% head
  }
}



ldply2 = function(x, # data 
                  index = NA, # see unique.comb()
                  condtion_L = NA,
                  unique_var = NA, # see unique.comb()
                  func, # similar as function in ldply. here its first element must be the subset of the data
                  ...){

  # from attach_load_first.R
  
  # similar as ldply, bust save a lot of code

  
  ldply (condtion_L, function(condtion_v){ # for each condtion group
    
    # x = diamonds
    # condtion_v = NA
    
    # subset data
    x_subset = subset_multiple(x,condtion_v= condtion_v)
    
    
    # indexed summary
    index_data = unique.comb(x = x_subset, index =  index, unique_var = unique_var)
    index_data = var_to_value(index_data[,index])
  
    
    names(index) = index
    
    ldply(1:nrow(index_data),function(i){
      # i = 1
      
      index_data_i = index_data[i,]
      print(index_data_i)
      
      # get the subset at one time, no need to write ldply(ldply(ldply(  subset(..,///))))
      data = subset_multiple(x,condtion_v = index_data_i)
      
      
      if (nrow(data)) {
        # automatically add the index
        result_func = func(data = data, index_data_i = index_data_i,...)
        # result_func = func(data = data, index = index_data_i)
        
        index_data_i = deletenames(index_data_i, colnames(result_func))
        
        rownames(index_data_i) = NULL
        cbind(index_data_i,result_func)
      }
    })
    
    
    
    
    
    
  return( 
    
 
  )
  
  
  if (F) {
    
    test =ldply2(x = diamonds,index_data_i = c("price>=500","color"),
                 func = function(data){
      mean(data$price,na.rm= T)
      })
    test
    test$color %>% class
  }
  
}




###  Data Clean Functions  -------------------
# _______________________________________________________________________




col_class_change = function(x){
  
  # an attach_Load_First.R function
  
  # change the class of each variable to its appropriate classes
  # see example in the end
  
  # x = sample_data 
  NA_place = NULL
  for (i in 1:ncol(x)){  
    # i = 3
    
    if (sum(is.na(x[i])) == length(x[,i]) ){
      NA_place = c(NA_place,i)
    } else if (class(x[,i]) %in% c("character","factor")) {
      if ( sum(is.na(as.numeric(x[,i]))) > sum(is.na((x[,i])),na.rm=T)  ){
        x[,i] = as.character(x[,i])
      } else {
        x[,i] = as.numeric(x[,i])
      }
    }
  }
  if (!is.null(NA_place)) x = x[,-NA_place]
  
  return(x)
  
  if (F){
    # change the text that purely contains numbers into class numeric
    sample_data = data.frame(one=c(NA,NA),
                             two = c("1","2"),
                             three = c("31",".1"),
                             three = c("31","a.1"))
    
    col_class_change(sample_data)
    
    
    str_detect("11`2.","\\D") & str_detect("112.1","\\D")
    
    as.numeric(c(NA,"2A"))
  }
}


Expand.grid = function (List, KEEP.OUT.ATTRS = TRUE, stringsAsFactors = TRUE) {
  
  # from attach_load_first.R
  
  # same as expand.grid, only difference is Expland.grid here uses list as input here
  # Create a data frame from all combinations of the supplied vectors or factors
  
  
  nargs <- length(args <- List)
  if (!nargs) 
    return(as.data.frame(list()))
  if (nargs == 1L && is.list(a1 <- args[[1L]])) 
    nargs <- length(args <- a1)
  if (nargs == 0L) 
    return(as.data.frame(list()))
  cargs <- vector("list", nargs)
  iArgs <- seq_len(nargs)
  nmc <- paste0("Var", iArgs)
  nm <- names(args)
  if (is.null(nm)) 
    nm <- nmc
  else if (any(ng0 <- nzchar(nm))) 
    nmc[ng0] <- nm[ng0]
  names(cargs) <- nmc
  rep.fac <- 1L
  d <- sapply(args, length)
  if (KEEP.OUT.ATTRS) {
    dn <- vector("list", nargs)
    names(dn) <- nmc
  }
  orep <- prod(d)
  if (orep == 0L) {
    for (i in iArgs) cargs[[i]] <- args[[i]][FALSE]
  }
  else {
    for (i in iArgs) {
      x <- args[[i]]
      if (KEEP.OUT.ATTRS) 
        dn[[i]] <- paste0(nmc[i], "=", if (is.numeric(x)) 
          format(x)
          else x)
      nx <- length(x)
      orep <- orep/nx
      x <- x[rep.int(rep.int(seq_len(nx), rep.int(rep.fac, 
                                                  nx)), orep)]
      if (stringsAsFactors && !is.factor(x) && is.character(x)) 
        x <- factor(x, levels = unique(x))
      cargs[[i]] <- x
      rep.fac <- rep.fac * nx
    }
  }
  if (KEEP.OUT.ATTRS) 
    attr(cargs, "out.attrs") <- list(dim = d, dimnames = dn)
  rn <- .set_row_names(as.integer(prod(d)))
  structure(cargs, class = "data.frame", row.names = rn)
  
  # Expand.grid(list(A= c(1:3),b= letters[1:4]))
  # Expand.grid(List = list(c(1:3)))
  
}


###  Sanity Checks  -------------------
# _____________________________________________________________________________



# check missing values in each = coloumn
complete.col = function(Data){
  ldply(1:ncol(Data),function(x){
    data.frame(colnames = colnames(Data)[x], 
               missing_freq = sum(is.na(Data[,x]))
    )
  })
}


check_vec_meaningful = function (x){ 
  
  # an attach_Load_First.R function
  
  # this function will check whether the vector is NULL or all values of it are NA NULL or NaN,
  # but we do allow logic(0) and integer(0)
  
  if (is.null(x) || length(x)==0) { # is.null will check the object as a whole, not each single element
    y = 0
  } else if ( !is.vector(x) || class(x)=='list') { # is.vector will return true for list and vector!
    stop('x is not a vector, it might be a list or data.frame or matrix ....')
  } else if (sum(is.na(x) + is.nan(x)  )==length(x) ){ # this method will allow logic(0) and integer(0)
    y = 0
  } else {
    y = 1
  } 
  
  return(y)
  
  if (F){
    
    check_vec_meaningful(c(NA,NA)) # NOT PASS
    check_vec_meaningful(x=list(NA,NaN)) # NOT PASS
    check_vec_meaningful(c(NA,1)) # PASS
    check_vec_meaningful(c(NULL,1)) # PASS
    
  }
}


check_signle_numeric = function(x, sign = 1){
  
  # an attach_Load_First.R function
  # check whether an object is a single numeric number
  
  if (sum(c('numeric','integer','logical') %in% class(x)) && length(x)==1 && x*sign>0) {
    x= 1
  } else {x = 0}
  
  return(x)
  
  if (F){
    check_signle_numeric(x = nrow(diamonds)) 
  }
}


####  unit test

# 

sanity_check = function(x = Campaign,
                        NULL_allowed = F, # whether is.NULL is allowed
                        Class=NULL, # Class is the correct class that x should be in
                        min_oberserv=NULL, # min_oberserv is the min number of row / length that x should have 
                        exact_in_match=NULL, # eahc element of x shall be found in the exact_in_match vector
                                        # if exact_in_match is a data.frame, we will get the colnames of it as exact_in_match
                        fuzzy_match = NULL,    
                        exact_length=NULL, # exact_length can let you test the exact length of a vector, OR exact number of colnames
                        complete_cases=NULL,
                        STOP = 1, # STOP: whether to stop if there is an error.
                        message_provided = ''
){
  # from attach_load_first.R
  
  # Goal: check whether the inout is in the right class, or right length , or right values....
  # x is the object you want to check
  
  Show_Name=deparse(substitute(x)) # to let the code print the original name of x
  
  Message = NULL
  
  eval(x) # to text existence
  
  
  ## --------------  check null       
  if (NULL_allowed == F && is.null(x)) stop(x, ' is NULL, which is not allowed')
  
  ## --------------  check class       
  
  if (check_vec_meaningful(Class)){
    
    Input_Class=class(x)
    #  if integer and numeric class, we treate them as same
    if (sum(c('integer','numeric','logical') %in% Class)) { 
      # Class = 'test'
      Class=c(Class,c('numeric','integer','logical'))
    }
    
    # check class
    
    if (sum(Class %in% Input_Class)==0){     
      cat("\n \n------------------- \n")
      
      Message = 
        paste("\n",Show_Name," is in ",class(x), "\n","It shall be in class ",paste(Class,collapse = ' or '),"\n")
    }
  }
  
  
  
  ## --------------  check exact values:
  if ("data.frame" %in% class(exact_in_match)) exact_in_match = colnames(exact_in_match)
  if (check_vec_meaningful(exact_in_match) ){
    
    if ( !is.vector(x) & !sum(c('data.frame',"matrix") %in% class(x) )) {
      stop("x must be a vector or matrix or data.frame when you want to check its match")     
    }
    
    if (
      # if x is the vector, then try to match the value
      (is.vector(x) && sum(x %in% exact_in_match)!=length(x)  ) || 
      # if x is a data.frame, then try to match the colnames
      (sum(c('data.frame',"matrix") %in% class(x) ) && sum(colnames(x) %in% exact_in_match)!=ncol(x) )
    ){
      
      cat("\n \n------------------- \n")
      print(exact_in_match)
      Message = paste("\n",Show_Name," shall have values / colnames above \n \n")
    }
  }
  
  ## -------------- check fuzzy values
  
  # eahc element of x shall be fuzzy matched in the fuzzy_match vector
  
  if ("data.frame" %in% class(fuzzy_match)) fuzzy_match = colnames(fuzzy_match)
  if (check_vec_meaningful(fuzzy_match) ){
    
    if ( !is.vector(x) & !sum(c('data.frame',"matrix") %in% class(x) )) {
      stop("x must be a vector or matrix or data.frame when you want to check its match")     
    }
    
    
    # if x is the vector, then try to match the value
    if (is.vector(x)) x_match = x 
    if (sum(c('data.frame',"matrix") %in% class(x))) x_match = colnames(x)
    
     for (M in x_match) { 

       if (sum(str_detect(M,fuzzy_match))==0){
         
        cat("\n \n------------------- \n")
        print(fuzzy_match)
        Message = paste("\n",Show_Name," shall have values / colnames above \n \n")
        print(Message)
       }
     }
  }
  
  
  ## -------------- check lengths
  if (  check_vec_meaningful(exact_length) ) {
    
    if (!check_signle_numeric(exact_length)) {
      stop ('exact_length must be numeric and has single value larger than 1')
    }
    
    if ( !is.vector(x) & !sum(c('data.frame',"matrix") %in% class(x) )) {
      stop("x must be a vector or matrix or data.frame when you want to check its length or number of cols")     
    }
    
    if ( 
      (is.vector(x) && length(x)!=exact_length) | 
      (sum(c('data.frame',"matrix") %in% class(x) ) && ncol(x)!=exact_length)
    ){
      cat("\n \n------------------- \n")
      Message = paste("\n",Show_Name," shall have the length / number of columns as ", exact_length,"\n")
    }
  }
  
  # -------------  check min_oberserv, if you defined min_oberserv   
  if (check_vec_meaningful(min_oberserv)){
    
    if (!check_signle_numeric(min_oberserv)){
      stop ("min_oberserv shall have a single numeric positive values" )
    }
    
    
    if (
      (class(x) %in% c("data.frame","matrix") && nrow(x)<min_oberserv) ||  
      (is.null(nrow(x)) && length(x)<min_oberserv)
    ){
      cat("\n \n------------------- \n")
      
      Message = 
        paste(
          "\n",
          Show_Name, " shall have more observations than ", min_oberserv,
          "\n"
        )
    }
  }
  
  ## ---------- check min_oberserv
  if ((check_vec_meaningful(complete_cases)) && complete_cases && 
      !is.null(nrow(x)) &&
      !sum(complete.cases(x))==nrow(x) ){
    Message = 
      paste("\n \n------------------- \n")
    
    Rows_NA=which(complete.cases(x)==0)
    cat(Rows_NA)
    
    Message = 
      paste("\n","Rows above has NA","\n")
  }
  
  
  if (length(Message)){
    cat(message_provided)
    
    if (STOP == 1) {
      stop(Message)
    } else {
      warning(Message)
    } 
  }
  
  if (F){
    
    ###_____ unit test ____
    
    sanity_check(dasfdfdsfsgre)
    sanity_check(dasfdfdsfsgre)
    
    
    null_checl = NULL ; sanity_check(null_checl)
    sanity_check(null_checl,NULL_allowed = T)
    
    sanity_check(c('x','y'),min_oberserv = 3)
    sanity_check(c('x','y'),min_oberserv = 2)
    
    sanity_check(diamonds,Class = 'data.frame2')
    sanity_check(diamonds,min_oberserv = 3000000)
    sanity_check(diamonds,exact_length = ncol(diamonds) )
    sanity_check(data.frame(diamonds,NA)[1:10,],complete_cases = T )
    
    colnames(diamonds)
    sanity_check(x= c('carat') ,exact_in_match = diamonds)
    sanity_check(x= c('carat') ,exact_in_match = colnames(diamonds))
    sanity_check(x= c('carat2') ,exact_in_match = diamonds)
    sanity_check(x= c('carat','carat2') ,exact_in_match = diamonds)
    
    sanity_check(x=colnames(diamonds),exact_in_match = c('carat'))
    sanity_check(x=diamonds,exact_in_match = c('carat2'))
    
  }
  
}



# _____________________________________________________________


###  Model Functions  -------------------
# _______________________________________________________________________

# _____________________________________________________________

stripGlmLR = function(cm) {
  
  # from attach_load_first.R
  
  # Trimming the Fat from glm() Models in R: reduce the size of it
  # http://www.r-bloggers.com/trimming-the-fat-from-glm-models-in-r/
  
  cm$y = c()
  cm$model = c()
  
  cm$residuals = c()
  cm$fitted.values = c()
  cm$effects = c()
  cm$qr$qr = c()  
  cm$linear.predictors = c()
  cm$weights = c()
  cm$prior.weights = c()
  cm$data = c()
  
  
  cm$family$variance = c()
  cm$family$dev.resids = c()
  cm$family$aic = c()
  cm$family$validmu = c()
  cm$family$simulate = c()
  attr(cm$terms,".Environment") = c()
  attr(cm$formula,".Environment") = c()
  
  cm
}

getModelSize = function(n) {
  
  # from attach_load_first.R
  # get the model size
  
  data = synthFrame(n)
  model = stripGlmLR(glm(y~xN+xC,data=data,
                         family=binomial(link='logit'),
                         y=FALSE, model=FALSE))
  length(serialize(model, NULL))
}

string_tidy = function(test_string,
                       Sep = "  ", # separator of words in the original strings
                       to_be_replaced = NULL, 
                       replacing = NULL){
  
  # from attach_load_first.R
  
  
  # this code can make a series of string tidy,
    # by 1. deleting the empty spaces, 
    # by 2. replacing the lengthy words by abbreviation.
  
  Replace = F   # by default, just clean the strings, not replacing, 
  # if to_be_replaced & replacing is provided, then we do replacing!
  if (class(to_be_replaced) == 'character' &&  class(replacing) == 'character') Replace = T
  
  # ldply below will delete the additional spaces and do replacing if Replace = T
  labels_split = ldply(str_split(test_string, Sep), # separate each string into words
                       function(Row){
                         
                         # Row = str_split(test_string, Sep)[[1]]
                         
                         Row = str_trim(Row,side = "both") # delete the space both sides
                         Row = Row[!(Row %in% "")] # drop the empty words
                         
                         # begin replacing!!!
                         j = 1 
                         while (Replace == T &&  j<=length(Row)){
                           
                           # j=1
                           # cat(j)
                           if (   Row[j] %in%  to_be_replaced  ) { # if find the to_be_replaced in the words, then replace it
                             Row[j] = replacing[to_be_replaced %in% Row[j] ]
                           }
                           j = j+1
                         }
                         Row
                       })
  
  #  Row =  c("PA"     ,     "DIRECT MAIL" ,"BT_DURATION"   )
  #  to_be_replaced = c("DIRECT MAIL" ,"BT_DURATION" ); replacing = c("DM" ,"BTD" )
  
  
  ## try to make each of the string the same length
  Length_Vector = apply(labels_split,2,function(string){str_length(str_trim(string))})
  Max_Length =  apply(Length_Vector,2,max)
  
  for (col in 1:ncol(labels_split)){
    for (row in 1:nrow(labels_split)){
      
      # col = 1; row = 6
      if ( is.na(Length_Vector[row,col]) || is.null(Length_Vector[row,col])) next
      
      labels_split[row,col] = str_trim(labels_split[row,col])
      
      if (Length_Vector[row,col]<Max_Length[col]) {
        
        # row = 300
        labels_split[row,col] = str_pad(labels_split[row,col],Max_Length[col],side='right' )
        # cat(labels_split[row,col])
        # cat(labels_split[row,])
        
      }
    }
  }
  result = apply(labels_split,1,function(i){
    # i =6
                paste(i,sep='',collapse = Sep)
              })
  
  return(result)
  
  if ( F) {
    
    
      test_string = c("PA  DIRECT MAIL  BT_DURATION ", "PA  DIRECT MAIL  BT_DURATION", 
                    "PA  DIRECT MAIL  BT_LIFE", "PA  DIRECT MAIL  NO", "PA  DIRECT MAIL  PO", 
                    "GE  DIRECT MAIL  BT_DURATION", "ITA  DIRECT MAIL  BT_DURATION", 
                    "GE  GE  BT_DURATION")
    
      # TEST CODE 
      string_tidy(c(  c("aa bbb"),
                      c("bbb bbbnnnn")),Sep=' ')
  }
  
}


formula.paste = function(x){
  # from attach_load_first.R
  # paste a formula into text
  
  return(gsub(" ","", deparse(formula(x),width.cutoff = 500)))
  
  
  if(F){
    
    formula.paste(price~carat + 
                    cut)
    
  }
}

# 
# str_replace_all("Id(q_status_last2*dq_status_last*dq_status)",
#                 "\\*dq_status(?![A-z0-9\\_\\.])",
#                 "")


######  Unit test
# formula.replace(Formula = price~carat + cut,tobe_replaced = '\\+cut',replacing = '',method="model")
# formula.replace(Formula = price~ I(carat*cut) + carat + cut,tobe_replaced = 'carat',replacing = '') 



get_var_sign = function(result,concatenate = T){
  # from attach_load_first.R
  
  
  # INPUT is the result of an glm regression
  # output is a table with first col as variables, second col as their signs
  # first variable is always the dependent variable # second variable is usually intercept
  
  Coeff = summary(result)$coefficient
  if ( concatenate)  rownames(Coeff) = gsub(" ","",rownames(Coeff))
  
  # paste formula in one line as character
  Formula = deparse(formula(result),500)
  
  # get the target variable
  target_position_end = str_locate( Formula,'~')[1] # target variable must locate before the '~' in the formula
  Target_Variable = str_trim(str_sub( Formula,1,target_position_end-1))
  
  if ( concatenate) Target_Variable =  gsub(" ","",Target_Variable)
  
  Coeff_Table = data.frame(
    Variables = c(Target_Variable,rownames(Coeff)),
    Sign = c(NA,Coeff[,1]>0), # whether it is postive
    Coeff = c(NA,Coeff[,1])
  )
  
  # if not positive, then negative
  Coeff_Table$Sign[Coeff_Table$Sign==0] = -1
  
  rownames(Coeff_Table)=NULL
  Coeff_Table
  
  # unit test 
  # get_var_sign(lm(price~carat+cut,diamonds))
  
}





get_x = function(result = diamond_lm, method = c("raw","model","coeff"), 
                 exclude.intercept = T,  # whether to exlude intercept
                 exclude.y = T, # whether to exlude y
                 data = NULL,  # to replace "." in the model wiht vars in data.
                 perl = F, # when excluding or including certain strings, whether to use regular expression
                 joint_include = NULL, 
                 union_include = NULL, 
                 joint_exclude = NULL
){
  # from attach_load_first.R
  
  # if method = "raw": only get the raw var: you will get "x" instead of "log(x)" from formula y~log(x).
  # if method = "model": only get the raw var: you will get "x" instead of "log(x)" from formula y~log(x).
  # if method = "coeff": used for categorical variables, you will get 
      # "cut.L"       "cut.Q"       "cut.C"       "cut^4"
      # instead of just cut
      # from lm(price ~ cut,data = diamonds)
  
  method = match.arg(method)
  if (is.null(data)) data=data.frame(DELETE_LATER.....123.= 0) 
      # some formulas contain "." to represent all other vars in data.
      # if data is null, then "." has no meaning at all
      # so we want to delete it
      # just replace "." by "DELETE_LATER.....123." temporily, later we will delete it.
      # so this "DELETE_LATER.....123." is just a temp place holder
  
  
  if (method == "raw") {
    var = all.vars(formula (result))
    if (exclude.y == T) var = var[-1]
  }
  
  if (method == "model") var = terms(result,data = data) %>% attr(.,"factors") %>% colnames()
  if (method == "coeff") {
    var = model.matrix(result) %>% colnames()
    if (exclude.intercept) var = var["(Intercept)" !=var] 
  }
  
  var = gsub(" ","",var)
  
  
  ## ???
  for (type in c("joint_include", "joint_exclude" ,"union_include")){
    
    to_be_test =eval(as.name(type))
    
    if (! is.null(to_be_test)){
      var_match = 0
      
      to_be_test = gsub(" ","",to_be_test)
      # include = c("carat","cut")
      for (x in to_be_test){
        # x = 'carat'
        if (perl == F) x= fixed(x)
        var_match = str_detect(var, x) + var_match
      }
      if (type == 'joint_include')   var_match = var_match == length(joint_include)
      if (type == 'joint_exclude')   var_match = var_match == 0      
      if (type == 'union_include')   var_match = var_match>0
      var = var[var_match]
    }
  }
  
  
  return(var[var != "DELETE_LATER.....123."])
  
  
  
  if (F) {
    
    diamond_lm  = lm(price~  I(carat^   2) + cut  + carat*table ,diamonds)
    case_inf = glm(case ~ age + education , infert,family = "binomial")
    
    get_x(diamond_lm,method = 'raw')
    get_x(diamond_lm,method = 'raw',exclude.y = F)
    get_x(diamond_lm,method = 'model')
    get_x(diamond_lm,method = 'coeff')
    get_x(diamond_lm,method = 'coeff',exclude.intercept = F)
    
    
    # DOC: 
    
    
    # only select variables that include all the elments in joint_include
    get_x(diamond_lm,joint_include = c("carat","table"),method = "model") 
    
    # only select vars that include at least one element in union_include
    get_x(diamond_lm,union_include = c("carat","table"))
    get_x(diamond_lm,union_include = c("carat","table"), method = "model")
      
    # exclude vars that contain at most one element in joint_exclude
    get_x(diamond_lm,joint_exclude = c("carat","table"))
    
    
    
    
  }
}



get_y = function(Formula,method = c("raw","model","coeff")){
  # from attach_load_first.R
  
  # depend on get_x
  
  method = match.arg(method)
  if (method == "raw") {
    result = get_x(formula(Formula),exclude.y = F)[1]
    
  } else {
    Formula = gsub(" ","",deparse(formula(Formula),500))
    result = gsub("\\~.*","",Formula,perl = T)
  }
  
  return(result)
  
  if ( F ) { 
    get_y(log(price) ~sdfsf + dsa ~dsad)
    get_y(log(price) ~sdfsf + dsa ~dsad, method = "coeff")
    get_y(log(price) ~sdfsf + dsa ~dsad, method = "model")
  }
}


get_x_all = function(Formula){
  # from attach_load_first.R
  
  # get all x together from the formula as a single formula, without y
    # see the example
  # depend on get_y and get_x
  
  y = get_y(Formula,"model")
  Formula = gsub(" ","",deparse(formula(Formula),500))
  return(gsub(paste(y,"~",sep=''),"",Formula,fixed = T))
  
  if(F){
    
    get_x_all(Formula = log(price) ~sdfsf + dsa ~ dsad +.)
    
  }
}


# 
# 
# ### unit test
# 





Effects = function( model = diamond_lm3, 
                    Data, 
                    focus_var_raw=c('carat',"depth"), # must be the raw vars in the model
                    focus_var_coeff=NULL,   # must be the coeff vars in the model
                    focus_value = NULL,  
                    # a list, each element of the list must have names in focus_var_raw, and contain at least 2 values of the key coeff vars
                    # at least 2 vlaues shall be provided, as we want to get the effects of it on the dependent
                    nonfocus_value = NULL, 
                    # a list, each element of the list must have names in non focus_var_raw, and contain at most 1 values of the key coeff vars
                    # only one vlaue can be provided, as we want to fix those non focus vars.
                    transform_y = NULL, # a function on y (ex. log(y) )
                    PRINT = T, 
                    Reverse = T # when plot, whether to use reverse order in x-axis (ex. for balance_left)
){
  
  
  # Main usage:: check the effects of the key raw variable (key_focus), focus_var_raw[1], on the dependent.
    # If focus_var_raw[2] exists, then we call it non-key focus raw var,
        # then we will check the effects of the first raw var under different values of the second raw.
    
  # the function will also check if the dependent vars is monotonic under different values of the key_focus
    # if focus_var_raw[2] exists, then we will check if it is monotonic under different values of focus_var_raw[2] 
  
  # you can also focus on effects of key_focus through only certain coeff vars.
    # you need specify those coeff vars, focus_var_coeff in the arguments. then all other coeff vars unspecified will have coeff 0
    # by default, focus_var_coeff is null, which means we will check effect of key_focus on all coeff vars.
  
  # by default, effects of key_focus through its value seq(0.05,0.95,by = 0.05) quantitles will be shown.
    # you can also provid values of all raws through argument focus_value (for focus_var_raw), and nonfocus_value for non-focus var 
    # by default, for all non-key non_focus raw vars, we assume their values are fixed at mean (if numeric) or mode (if factor or character) .
    
  
  # what is "raw var" / "model var" and "coeff var"
    # in price ~ I(carat * depth) + I(carat>1), carat and depth are raw, but not model var,
    # "model vars" here are "I(carat * depth)" and "I(carat>1)"
    # "coeff vars" here are "I(carat * depth)" and "I(carat>1)TRUE"
    # "coeff vars" only exist after running the model
    # "raw vars" and "model vars" exist when formula is created.
  
  
  
  # preg = model =  glm(case ~ I(age>35) + spontaneous, data = infert,family = "binomial")
  # Data = infert
  
  
  ### ------------------------   check 
  
  all_raw_var = get_x(model)
  all_coeff = get_x(model,method = "coeff")
  y = get_y(model,"coeff")
  names(model$coefficients) = gsub(" ","",names(model$coefficients)) # standardized the names
  
  
  sanity_check(focus_var_raw, exact_in_match = all_raw_var )
  sanity_check(Data) 
  if (sum(colnames(Data) %in% all_raw_var) < length(all_raw_var)) stop("Data provided is missing some raw vars for this regression")
  
  if (length(nonfocus_value)) {
    sanity_check(nonfocus_value, Class = 'list')
    sanity_check(names(nonfocus_value), exact_in_match = all_raw_var)
    for (x in nonfocus_value){
      sanity_check(x, exact_length = 1, message_provided = "Only 1 value can be provided for each non focus vars")
    }
  }
  
  if (length(focus_var_raw)>2) stop("You can only focus on at most two variables")
  if (length(focus_value)) {
    sanity_check(focus_value, Class = 'list')
    sanity_check(names(focus_value), exact_in_match = all_raw_var )
    for (x in focus_value){
      sanity_check(x,min_oberserv = 2,
                   message_provided = 'The provided values for each focus raw var shall at least have to different values to enable monoton comparsion')
    }
  }
  
  if (length(transform_y)) sanity_check(transform_y, Class = 'function')
  
  
  ### ------------------------    values for non-focus varaibles
  
  #   llply(diamonds,function(x){
  #      print(paste( class(x),collapse=' '))
  #   })
  
  ##~~~~~~~~   get the mean or average for all raw vars
  
  all_raw_values = list()
  for ( each_raw_var in all_raw_var) {
    x = Data[,each_raw_var]
    Class = paste( class(x),collapse=' ')
    if ( Class %in% c("numeric","integer")){
      all_raw_values[[each_raw_var]] = mean(x)
    } else {
      # for factor or character, we assume Mode
      all_raw_values[[each_raw_var]] = Mode(x)
    }
  }
  
  # if you provide the values to the non-focus vars, then replace the mean/mode by the provided ones.
  if (length(nonfocus_value)){
    for( x in names(nonfocus_value)){
      all_raw_values[[x]] = nonfocus_value[[x]]
    }
  }
  
  ### get the valueS for focus raw vars
  # if numeric: 
  # get seq(0.015,0.95,0.3 ) quanttile values for the non-key focus vars
  # get seq(0.015,0.95,0.05 ) quanttile values for the key focus vars
  # if not :
  # get the unique values
  
  is_factor_key  = c(1,1)
  names(is_factor_key) = focus_var_raw
  i=1
  
  for( x in focus_var_raw){
    # x = focus_var_raw[1]
    is_factor_key[x] = sum(c("factor","character") %in% class(all_raw_values[[x]] ))
    
    if (x %in% names(focus_value)) {   # if values are provided for focus variables
      all_raw_values[[x]] = focus_value[[x]]
      
    } else if ( # if not provided,
      is_factor_key[x]
    ){
      # for factors and characters
      all_raw_values[[x]] =  focus_value[[x]] = unique(Data[,x])
    } else if ( i== 2 & is_factor_key[1]) { # for numerics
      # if the first focus var is a factor/character, and second focus var is a numeric, then we just don't need a very detailed quantitle for the socnde one
      # i = 2 
      all_raw_values[[x]] =  focus_value[[x]] =   unique(quantile(Data[,x],seq(0.015,0.95,0.3 )))
    } else {
      all_raw_values[[x]] =  focus_value[[x]] =   unique(quantile(Data[,x],seq(0.015,0.95,0.05 )))
    }
    i = i + 1
  }
  
  
  # ------------------- Prediction ~~~~~~~~~~~~~~~~~~~~~~~~```
  
  # prepare data for predict()
  modeled_data = Expand.grid(all_raw_values,stringsAsFactors = F)
  model_use = model
  
  # if you only focus the effects of certain coeff vars, then assign all other coeff vars to 0
  if (!is.null(focus_var_coeff)){
    sanity_check(focus_var_coeff, exact_in_match = all_coeff )
    
    replacement = model$coefficients # model = Result
    names(replacement) = gsub(" ","",names(replacement))
    # focus_var_coeff = '(Intercept)'
    replacement[!names(replacement) %in% focus_var_coeff] = 0 
    
    model_use$coefficients = replacement
  }
  
  final_data =  data.frame(predict = predict(model_use,modeled_data,type='response'),modeled_data)
  
  ### check the monoton
  # when there is only one focus var: the key
  if (length(focus_var_raw) ==1 ) {
    final_data = final_data[order(final_data[,focus_var_raw[1]]),]
    monoton_increase = is.increase(final_data$predict)
    monoton_decrease = is.decrease(final_data$predict)
  }
  # when there are focus vars: the key and non-key, we check each the monoton effectt under each value of the non-key
  if (length(focus_var_raw) ==2 ) {
    
    final_data = data.table(final_data)
    final_data = setorderv(final_data, focus_var_raw[2:1]) %>% data.frame
    
    unique_key_focus = unique(final_data[,focus_var_raw[2]])
    
    monoton_increase = laply(unique_key_focus, function(x){
      is.increase(final_data[final_data[,focus_var_raw[2]] ==x, ]$predict)
    })
    
    monoton_decrease = laply(unique_key_focus, function(x){
      is.decrease(final_data[final_data[,focus_var_raw[2]] ==x, ]$predict)
    })
    
    names(monoton_decrease) = unique_key_focus
    names(monoton_increase) = unique_key_focus
    
  }
  
  
  # ------------------- For Plot ~~~~~~~~~~~~~~~~~~~~~~~~```
  
  plot_data = final_data 
  
  # whether the target variable needs some tranform function?
  if (!is.null(transform_y)){
    plot_data$predict =  final_data$predict = transform_y(plot_data$predict)
  }
  
  # initialize the graph
  graph = NULL
  
  # if the key focus var only has at most 10 unique values, then transfer it to factor when plot
  if (PRINT){
    Length_Unique = plot_data[,focus_var_raw[1]] %>% unique %>% length
    if (Length_Unique<=10) {
      plot_data[,focus_var_raw[1]] = as.factor(plot_data[,focus_var_raw[1]])
      is_factor_key[1] = 1 
    }
    
    # plot according to number of focus variables
    if (length(focus_var_raw) ==1 ) { 
      
      if (is_factor_key[1]>0){
        # if it is a character, then use bar to plot
        graph = 
          ggplot(plot_data) + geom_bar(aes_string(x=focus_var_raw[1], y = 'predict'),stat = "identity") +
          labs(y=y) 
      } else {
        graph = 
          ggplot(plot_data) + geom_line(aes_string(x=focus_var_raw[1], y = 'predict')) +
          labs(y=y)
      }
    }
    # 
    if (length(focus_var_raw)==2) {           
      
      Class_col = paste( class(plot_data[,focus_var_raw[2]]),collapse=' ')
      
      if (!is_factor_key[2]) { # transfer the secondary key into factor
        plot_data[,focus_var_raw[2]] = as.factor(plot_data[,focus_var_raw[2]])
      }
      
      if ( is_factor_key[1] ){
        graph = ggplot(plot_data) + geom_bar(aes_string(x=focus_var_raw[1], fill = focus_var_raw[2], y = 'predict'),stat = "identity") +
          labs(y=y)
      } else { 
        graph = ggplot(plot_data) + geom_line(aes_string(x=focus_var_raw[1], colour = focus_var_raw[2], y = 'predict')) +
          labs(y=y)
      }
      
    }
    
    if (Reverse && is_factor_key[1] == 0) graph = graph + scale_x_reverse() # factor cannot use reverse
    print(graph)
  }
  
  Coeff_table = data.frame(Var = names(model$coefficients) , value = model$coefficients)
  rownames(Coeff_table) = NULL
  
  list(
    Focus_values = focus_value,
    data_and_predict = final_data,
    summmary_glm = Coeff_table,
    Monoton_Increase = monoton_increase,
    Monoton_Decrease = monoton_decrease,
    Graph = graph
  )
}

# ##___ unit test ____
# 
# # ~~~~~~~~~~~~~ Basic
# 
# preg = reulst = glm(case ~ I(age>35) + spontaneous + I(age*spontaneous), data = infert,family = "binomial")
# # 
# Effects(preg, focus_var_raw = 'age', focus_var_coeff = c("I(age>35)TRUE"),Data = infert,PRINT = T)
# Effects(preg, focus_var_raw = 'age', focus_var_coeff = c("I(age*spontaneous)"),Data = infert,PRINT = T)
# 
# # ERROR
# Effects(preg, focus_var_raw = 'age', focus_var_coeff = c("age>35"),Data = infert,PRINT = T)
# 
# 
# 
# diamond_lm3 = lm(price~ cut + carat + I(carat^2) + I(carat^3) + I(carat  * depth),diamonds) # a GLM  
# Effects(model = diamond_lm3,Data = diamonds, focus_var_raw=c('carat'))
# #~~~~~~~~~~~~~  for categorical
# Effects(model = diamond_lm3,Data = diamonds, focus_var_raw=c('cut'))
# 
# #~~~~~~~~~~~~~  for double
# Effects(model = diamond_lm3,Data = diamonds, focus_var_raw=c('carat',"cut"))
# Effects(model = diamond_lm3,Data = diamonds, focus_var_raw=c('carat',"depth"))
# 
# Effects(model = diamond_lm3,Data = diamonds, focus_var_raw=c("cut","carat"))
# 
# #~~~~~~~~~~~~~ only fucus on certain values
# Effects(model = diamond_lm3,Data = diamonds, focus_var_raw=c('carat',"cut"),
#         focus_var_coeff = c("I(carat^2)","cut.L","cut.Q","cut.C","I(carat*depth)"))
# 
# # also to test the monoton
# Effects(model = diamond_lm3,Data = diamonds, focus_var_raw=c('carat',"cut"),
#         focus_var_coeff = c("I(carat^3)","cut.L","cut.Q","cut.C","I(carat*depth)"))
# 
# #~~~~~~~~~~~~~ Provided values
# # also to test the monoton
# Effects(model = diamond_lm3,Data = diamonds, focus_var_raw=c('carat',"cut"),focus_value = list(carat=seq(0.5,6,0.1)))
# 
# # wrong examples
# Effects(model = diamond_lm3,Data = diamonds, focus_var_raw=c('carat',"cut"), focus_var_coeff = c("I(carat^2)","cut"))
# Effects(model = diamond_lm3,Data = diamonds, focus_var_raw=c('carat',"cut7897"))

# _____________________________________________________________


###  Algorithm Functions  -------------------
# _______________________________________________________________
# _____________________________________________________________

stepwise2 =function (object, # can be an glm/lm/formula, 
                     scope, 
                     trace = 1, 
                     keep = NULL, 
                     steps = 1000, 
                     k = 2, 
                     data = diamonds, 
                     family = gaussian(link = "identity"), # argument for familiy for glm
                     IC_method = c("AIC","BIC"), 
                     test_suit = NULL, # see delete_wrongsign()
                     STOP = F, # see delete_wrongsign()
                     PRINT = F, # see delete_wrongsign()
                     ...) 
{
  
  IC_method = match.arg(IC_method)
  # IC_method = "BIC"
  
  if (IC_method == "BIC") {
    if (k==2 & trace)  cat("k is overwitten as log(N)")
    k = log(nrow(data))
  }
  
  y = get_y(object, method = "model")
  x_lower = get_x(scope$lower, method = "model")
  # x_start has vars as union of the lower and start model
  x_start = get_x(object, method = "model") %>% union(.,x_lower)
  # x_upper has vars as union of the lower, start nad upper  model
  x_upper = get_x(scope$upper, method = "model") %>% union(.,x_start)
  
  control = 1
  x_best = NULL
  x_best_row = NULL
  x_skip = NULL
  best_model = object
  
  while (control<999){
    
    list_upper = setdiff(x_upper,x_start) # vars to add
    list_lower = setdiff(x_start,x_lower) # vars to delete
    
    # x_delta: ~~~~~~~~~~~ denotions of the different models
    # if add a var, then denote it as "+ 'var'", otherwise as "- 'var'"
    # "---" is to denote the starting model in that step
    x_delta = c("---",paste("+",list_upper), paste("-",list_lower))
    x_delta = x_delta [!x_delta %in% c("+ ","- ")]
    
    Correct_Effect = nvar = IC = formula_new = NULL
    
    # within one step, try add or delete each var
    for (delta in x_delta ){
      # delta = x_delta [1]
      
      # create the formula
      if (delta == "---") {
        formula_new[delta] = paste(y,"~",paste(x_start,collapse = "+"))
      } else {
        formula_new[delta] = paste(y,"~",paste(x_start,collapse = "+"),delta) 
      }
      
      if (trace) { cat("\n\n") ; cat(formula_new[delta],"\n ------------------------\n")}
      
      new_model = glm(as.formula(formula_new[delta]),data = data, family = family)
      
      # do the test of marginal effect
      Correct_Effect[delta] = 1
      control_dw = 1
      
      while (!is.null(test_suit) && 
             Correct_Effect[delta] && # as long as we can get one wrong effect, then stop
             control_dw<=length(test_suit) # stop if we run out of the test sute
      ) {
        
        if (PRINT) cat("\n\n\n =========== add/delete var ",delta, " into the model ============= \n")
        # stop condition: encounter an incorrect sign OR run out of test suit 
        
        test_i = test_suit[[control_dw]] 
        
        if ( is.null(test_i$Monoton_to_Match)) test_i$Monoton_to_Match = 1
        if ( is.null(test_i$Reverse)) test_i$Reverse = T
        
        new_model = deleting_wrongsign (new_model, focus_var_raw = test_i$focus_var_raw, Reverse =  test_i$Reverse,
                                        family = family,
                                        Monoton_to_Match = test_i$Monoton_to_Match,re_evaluate = F,
                                        focus_var_coeff = test_i$focus_var_coeff,
                                        PRINT =  PRINT,
                                        Data = data, STOP = STOP)
        
        if (!is.null(new_model$Correct_Effect)) Correct_Effect[delta] = new_model$Correct_Effect
        control_dw = control_dw + 1
      }
      
      # record      
      nvar[delta] = length(get_x(new_model,"model"))
      IC[delta] = extractAIC(new_model,k = k)[2]
    }
    
    # to record
    result = data.frame(IC, nvar , control, Correct_Effect, formula_new)
    result = result[order(result$IC),]
    
    if (trace) cat("\n\n") ; print(result)
    
    # this is the best model you choose this steo
    x_best_row = result[result$Correct_Effect>0,][1,]
    if (x_best_row$Correct_Effect==0 | nrow(x_best_row)==0) stop("cannot choose the wrong specification according to the test suit")
    
    if (rownames(x_best_row) == '---'){   # if the best model is the original model, then stop
      control = 1000
      # print(deparse(formula(best_model),500))
    } else {  # if the best model is a new model, then we create a new x_start from the best model
      control = control + 1
      x_start = get_x(as.formula(x_best_row$formula_new),"model")
      
      # print(best_model)
      # print(x_start)
      
      # rownames(x_best_row) %>% str_replace(x_best,pattern = fixed("+ "),"")
    }
  }
  
  invisible(best_model)
  
}


# # 
# # ####### ------------------  unit test 
# # 
# diamond_lm3 = lm(formula = price ~ cut + carat  , data = diamonds)
# 
# scope = list(lower = price ~ 1, 
#              upper = price ~ .+ I(carat^2) + I(carat^3) + I(carat * depth) + depth)
# 
# test_suit = list(
#   carat = list(
#     focus_var_raw = "carat",
#     focus_var_coeff = c("I(carat^3)","I(carat*depth)","I(carat^2)","carat") ,
#     Monoton_to_Match = 1
#     ),
#   depth = list(
#     focus_var_raw = "depth",
#     Monoton_to_Match = 1
#   )
# )
#   
# test = stepwise2(object = diamond_lm3, scope = scope, 
#           trace = T, PRINT = T, data = diamonds, STOP = F,
#           test_suit = test_suit)
# 
# Upper_List = list(
#   level_1 = case ~ .+spontaneous,
#   level_2 = case ~ .+induced
# )
# 
# Test_Suit_test = list(test = list(focus_var_raw = "spontaneous",Monoton_to_Match = -1))
# 


# test = deleting_wrongsign(result = diamond_lm3, focus_var_raw = 'carat', 
#                           focus_var_coeff = c("I(carat^3)","I(carat*depth)","I(carat^2)","I(carat)"),
#                           focus_value = list(carat=seq(0.5,6,0.1)),Data = diamonds,PRINT = T,STOP =T)
# 
# test
# 
# # two focus on vars
# test = deleting_wrongsign(result = diamond_lm3 , 
#                           focus_var_raw = c('carat',"cut"), 
#                           focus_var_coeff = c("I(carat*depth)","I(carat^3)",get_x(diamond_lm3,method="model")),
#                           focus_value = list(carat=seq(0.5,6,0.1)),
#                           Data = diamonds,PRINT = T,STOP =T)
# 
# 
# ##  negative signs
# deleting_wrongsign(result = diamond_lm3 , 
#                    focus_var_raw = c('depth',"cut"), 
#                    focus_var_coeff = c("depth"),Monoton_to_Match = -1,
#                    Data = diamonds,PRINT = T,STOP =T)
# 
# 
# 
# deleting_wrongsign(diamond_lm, focus_var_raw = 'carat', focus_var_coeff = c("I(cara79t^3)"),Data = diamonds,PRINT = T)
# deleting_wrongsign(diamond_lm, focus_var_raw = 'carat890', focus_var_coeff = c("I(carat^3)"),Data = diamonds,PRINT = T)
# 
# 
# 
# 
# get_x(preg,"model")
# 





# 
# stepwise2(object = price ~ carat - 1, 
#           scope = list(lower =  . ~ 1, upper = price ~ table + cut*depth),
#           data = diamonds, test_suit = test_suit
#           )
# 
# 
# Stepwise(DATA = infert,
#          Upper = Upper_List,Test_Suit = Test_Suit_test,
#          PRINT = T,STOP = T)
# 
# 



Stepwise = function(DATA= infert, 
                    Upper= DQ_Upper,
                    Family = NULL, # gaussian(link = "identity") for OLS
                    Direction = 'forward',
                    Base = NULL, # the overall base formula when Upper is a list # usually it can be the most naive formula: depedent ~ 1
                    Test_Suit = NULL, # test siut
                    PRINT = T,
                    STOP = F,
                    method = c("BIC")){
  # !!!! you have to use defmacro, not the normal functions, as normal functions have bugs: stepAIC cannot find the development dataset.
  
  
  # this function enables Upper models as a list of models, and each step the stepwise AIC algorithm will only look 
  # variables within eahc element of the list.
  # only oafter searching completes for all variables in that list, will will continue to
  # include variables in the next level in the search 
  
  sanity_check(Upper,Class = c("formula","list"))
  sanity_check(Upper[[1]],Class = c("formula"))
  sanity_check(method,exact_in_match = c("AIC","BIC"))
  
  
  if (class(Upper)=='formula') Upper = list(Upper)
  
  # by pass the " invalid (do_set) left-hand side to assignment" bug in defmacro
  if (is.null(Base)) {
    Base2 = get_y(Upper[[1]],"coeff") %>% paste(.," ~1") %>%  as.formula 
  } else (Base2 = Base)
  
  
  cat("dependent var: ", get_y(Base2,"raw"))
  
  
  if (is.null(Family)) {
    
    Unique_Values_L = DATA[,get_y(Base2,"raw")] %>% unique
    Unique_Values_L = Unique_Values_L[!is.na(Unique_Values_L)]
    
    if ( length(Unique_Values_L) > 2) {
      Family2 = gaussian(link = "identity")
    } else {
      Family2 = 'binomial'
    }
  } else {Family2= Family } 
  
  cat("type of model: ", paste(Family2)[1])
  
  for (k in 1:length(Upper)){    
    
    # k=1
    if (PRINT){
      cat("\n \n -------------------------------------------------------------- ")
      cat("         Begin to include variables below      \n")
      print(Upper[[k]])
      cat("-------------------------------------------------------------- \n \n ")
    }
    
    # colnames(DATA)
    # ??stepAIC
    
    if (method=='AIC') K_punish = 2
    if (method=='BIC') K_punish = log(nrow(DATA)); cat("BIC is used")
    if (k==1) Result = Upper[[1]]
    
    Result = stepwise2(object =  Result,data = DATA,family = Family2,
                       scope =list(upper = Upper[[k]],lower = Base2 ),k = K_punish,
                       trace = PRINT)
    
    # always use the lowest model as the lower boundary
    
    # for the test suit
    
    
    Old_Formula  = 1 # initialize
    New_Formula = 0 # initialize
    
    if (PRINT) {
      cat("\n\n"); print(summary(Result)$coeff)
    }
    if (STOP ) Enter_to_Continue()
    
    while (!is.null(Test_Suit) && Old_Formula != New_Formula ) {
      Old_Formula = formula.paste(Result)
      
      for (test_i in Test_Suit){
        if ( is.null(test_i$Monoton_to_Match)) test_i$Monoton_to_Match = 1
        if ( is.null(test_i$Reverse)) test_i$Reverse = T
        
        Result = deleting_wrongsign (Result, focus_var_raw = test_i$focus_var_raw, Reverse =  test_i$Reverse,family = Family2,
                                     Monoton_to_Match = test_i$Monoton_to_Match,
                                     focus_var_coeff = test_i$focus_var_coeff,PRINT =  PRINT,Data = DATA, STOP = STOP)
      }
      
      New_Formula = formula.paste(Result)
    }
  }
  
  if ( PRINT ) { Result } else {invisible(Result)}
}

# ## UNIT TEST
# 
# Upper_List = list(
#   level_1 = case ~ .+spontaneous,
#   level_2 = case ~ .+induced
# )
# Test_Suit_test = list(test = list(focus_var_raw = "spontaneous",Monoton_to_Match = -1))
# 
# Stepwise(DATA = infert,
#          Upper = Upper_List,Test_Suit = Test_Suit_test,
#          PRINT = T,STOP = T)
# 
# 
# 



k_fold = function(one_fold, # a function whose input is train data, output is a model 
                  K =3 , # how many folds you want to run
                  seed = 10000, # seed
                  DATA, # data used for whole K-fold. 
                  # Inside the function we will separate it fro training and validating data
                  Simplify =  F, # make the model thinner (delete the useless attributes in model object)
                  PRINT = F
){
  sanity_check(one_fold,Class = 'function')  
  if (K<2) stop("K must be in integer larger than 2")
  
  Model = Error = Seed = NULL
  errors = c()
  
  function_envir = environment()
  
  for (i in 1:K){
    # i=1
    
    cat("\n =======================  Fold ", i," =============================\n")
    
    Seed[i] = seed+i-0
    set.seed(Seed[i])
    Random = runif(nrow(DATA))
    Train = DATA[Random> 1/K,]
    Validate = DATA[Random<= 1/K,]      
    
    
    if ( is.null(formals(one_fold)$PRINT)){
      Model[[i]] = one_fold(Train)
    } else {
      Model[[i]] = one_fold(Train, PRINT)
    }
    
    if (Simplify ==  T) Model[[i]] = stripGlmLR(Model[[i]])
    
    errors = Validate[, get_y(Model[[i]])  ] - predict(Model[[i]],newdata = Validate, type ='response')
    Error[i] = sum(errors^2)/(nrow(Validate)-1) 
    
    Error[i] = Error[[i]]^0.5
  }
  
  
  Result = list(Model,
                Error,
                best = which.min(Error),
                Seed)
  
  names(Result) = c("Model","Error","Which_Best","Seed")
  Result
}

#### unit test
# 
# Train =1
# k_fold( one_fold = function(wrwe,rwec,train = Train,tesy){
#                               lm(price~carat,train)
#                               },
#         DATA = diamonds , PRINT = T)







Delete_Insignificant = 
  function(result, # must be the return of a glm, can use summary() function on it
           Sig_Cutoff = 0.01 # the largest sig level you can accept
  ){
    
    
    
    # this function will return a string
    # if there is insignifcant variable, it will delete that variable from the formula, and return a string format of that formula
    # if there is no insiginifciant variable, it will return 'Nothing Deleted'
    
    # note that this function cannot deal with insignificant intercept!
    
    
    # unit test code
    
    #   Random_Y = rnorm(100)
    #   Random_Unif = runif(100)
    #   Random_X = Random_Y+Random_Unif
    #   Random_X_false = rnorm(100)
    #   
    #   result = lm(Random_Y ~ Random_X + Random_X_false)
    #   Delete_Insignificant(result)
    
    
    # delete the intercept row
    Coeff = summary(result)$coefficient[-1,]
    
    Formula = deparse(formula(result),500)
    
    # get the target variable
    target_position_end = str_locate( Formula,'~')[1] # target variable must locate before the '~' in the formula
    Target_Variable = str_trim(str_sub( Formula,1,target_position_end-1))
    
    if ( nrow(Coeff)>=1 & max(Coeff[,4])>Sig_Cutoff ){
      To_be_deleted = which.max(Coeff[,4]) 
      To_be_deleted_Variable = attributes(To_be_deleted)$name
      cat("\n",To_be_deleted_Variable,  " has P_Value as ", max(Coeff[,4])," larger than ", Sig_Cutoff, 
          ". Thus it shall be deleted. \n \n")
      
      Variables_Left = row.names(Coeff)[-To_be_deleted]
      Formula_New = paste(Target_Variable, "~",paste(Variables_Left,collapse = ' + '))
      
      cat("New formula is: \n \n")
      
      cat(Formula_New)
    } else {
      
      cat("\n Nothing Deleted \n")
      Formula_New = 'Nothing Deleted'
    }
    
    cat("\n ----------------------------------------------------------- \n")
    
    Formula_New
  }


# result = Model_DQ2
# Variable_to_Check = 'I(risk_decile_nbr * balance_left * Industry_Delinq_last)'



deleting_wrongsign = function (model = lm(price~I(carat^2)+cut,diamonds), # a GLM model 
                               focus_var_raw=c('carat'),  # see Effect()
                               focus_var_coeff= NULL,   # see Effect()
                               focus_value = NULL,   # see Effect()
                               nonfocus_value = NULL,   # see Effect()
                               transform_y = NULL,  # see Effect()
                               PRINT = T,
                               
                               Monoton_to_Match = 1,  # 1 means you want monotonic increasing marginal effect, -1 means negative
                               # the correct signs
                               re_evaluate = T, # if find the wrong marginal effect, whether to delete the wrong coeff and re-evaluate the model 
                               Data = NULL,# diamonds,
                               STOP = F, # stop at key checking point
                               Reverse = T, # whether the plot of marginal effects shall be reversed.
                               family = NULL){
  
  # this function will check whether the marginal effect of certain raw var is correct.
  # You have to read the function Effect() to understand how to get the marginal effect
  
  # if re_evaluate == T, then we will 
  # 1. drop the first coeff from focus_var_coeff
  # 2. revaluate the model, then check the marginal effect
  # repeat the two steps above until we get correct marginal effect or we delete all coeffs in focus_var_coeff.
  
  
  # model = diamond_lm
  # focus_var_raw = "carat"
  # focus_var_coeff =  c("I(carat^4)","I(carat^3)")
  
  ### __________________  initialize __________________
  if (is.null(family)) family = family(model)
  
  # for raw vars
  all_var_raw = all.vars(formula(model)) # model= Result
  in_raw = focus_var_raw %in% all_var_raw
  if (F %in% in_raw) {
    if (PRINT) cat("\n Effect check: raw var ", paste( focus_var_raw[!in_raw], collapse = ', '),", cannot be found in the model, so skip the check. Nothing changed. \n\n")
    return(invisible(model))
  }
  
  # for coeff vars
  if (is.null(focus_var_coeff)){ # if focus_var_coeff NOT Provided, then get all coeff-var that contatins the raw-var as the focus_var_coeff
    
    # model = preg
    focus_var_coeff = get_x(model,method = "model", union_include = focus_var_raw)
    focus_var_coeff[order(str_length(focus_var_coeff),decreasing = T)]
    
  } else {
    
    all_var_model = get_x(model,method = "model")
    focus_var_coeff = gsub(" ","",focus_var_coeff)
    focus_var_coeff = unique(focus_var_coeff)
    
    in_model = focus_var_coeff %in% all_var_model
    focus_var_coeff = focus_var_coeff[in_model] 
    
    if (length(focus_var_raw) ==0 ){
      cat("The updated focus_var_raw cannot be found in the model. Nothing changed\n")
      return(invisible(model))
      
    } else if (F %in% in_model & PRINT) {
      cat(" Effect check: model var: ", paste(focus_var_coeff[!in_model] ,collapse = ', '),", cannot be found in the model, So not check them \n")
    }
  }
  
  ### __________________  each time just delete one variable _________________
  
  control_var = 1
  focus_var_model_0 = focus_var_coeff
  
  if (re_evaluate) {
    max_steps = length(focus_var_model_0) # stop if find the correct effect or run out of the focus_var_model_0
  } else {
    max_steps = 1 # if not re_evaluate, then stop after the first step
  }
  
  while (control_var <= max_steps ){
    
    # Result$family
    
    var_loop = focus_var_model_0[control_var] # this is the model_var you want to delete in this time
    
    
    if (PRINT)  {
      if (control_var==1) {
        cat("\n ---------- \n  Effect check: initial Model is \n -------- \n ")
        print(summary(model)$coefficient[,c(1,4)])
      }
      
      cat("\n\n\  check raw var:",focus_var_raw[1],"\n")
      cat("check model var:", paste(focus_var_coeff,collapse = ", "),"\n")
      cat("Correct sign is:", paste(Monoton_to_Match),"\n")
    }
    
    effect = Effects(Reverse = Reverse,
                     model = model, 
                     Data = Data, 
                     focus_var_raw = focus_var_raw, 
                     focus_var_coeff = focus_var_coeff,  # be updated each time
                     focus_value = focus_value, 
                     nonfocus_value = nonfocus_value, 
                     transform_y = transform_y,
                     PRINT = PRINT
    )
    
    # if non-key var is provided, then we will check the marginal effects of the key-var under each non-key var
    # thus we need to use all() to insure all values of Monoton_Increase/Monoton_Decrease ==1
    if (   (Monoton_to_Match == 1 & all(effect$Monoton_Increase==1) ) | 
           (Monoton_to_Match == -1 & all(effect$Monoton_Decrease==1) )
    ){ 
      if (PRINT) cat(" ~~~~ Sign is correct ~~~~")
      control_var = length(focus_var_model_0) + 1 # stop
      Correct_Effect = 1 
    } else {
      if (PRINT) cat(" ~~~~~ !! Sign is incorrect. !! ~~~~~. Variable ", 
                     var_loop, " shall be deleted\n ")
      Correct_Effect = 0
    }
    
    ## --------------------------  Revaluate
    if ( Correct_Effect==0 & re_evaluate){
      
      model_var = get_x(model,"model")
      model_var = model_var[var_loop!=model_var]
      if (length(model_var)==0) model_var = "1"
      
      Formula_new = paste( paste(get_y(model,"model"),"~"),
                           paste(model_var,collapse = '+') # be careful with multiple variables to be deleted, so you have to collapse it
      ) %>% as.formula
      
      model = glm(Formula_new,data = Data,family = family)
      
      if (PRINT) {
        cat("\nNew Model: \n -------\n ")
        Coeffs = summary(model)$coefficient[,c(1,4)] %>% data.frame()
        row.names(Coeffs) = gsub(" ","",row.names(Coeffs))
        
        Coeffs[,'checked']  = row.names(Coeffs) %in% focus_var_coeff
        
        print(summary(model)$coefficient[,c(1,4)])
        
      }
      
    }
    
    ## update 
    focus_var_coeff = focus_var_coeff[!(focus_var_coeff %in% var_loop)] 
    control_var  = control_var + 1 # must do this after updating focus_var_coeff
    
    ## update focus_var_coeff each time, after you delete one variable
    # if the sign is correct or the variables_to_check cannot be found in the model, then just break the loop
    
    if ( length(focus_var_coeff)==0 & Correct_Effect==0) {
      control_var = length(focus_var_model_0) + 100 # stop
      if (re_evaluate) if (PRINT) cat("\n All model vars with wrong sign have been deleted, nothing to check now. \n")
    }
    if  (STOP) {
      Enter_to_Continue()
    }
  }
  model$Correct_Effect = Correct_Effect
  invisible(model)
}



# # # 
# # # ####### ------------------  unit test 
# # 
# diamond_lm3 = lm(formula = price ~ cut + carat + I(carat^2) + I(carat^3) + 
#                    I(carat * depth) + depth , data = diamonds)
# 
# test = deleting_wrongsign(model = diamond_lm3, focus_var_raw = 'carat', 
#                           focus_var_coeff = c("I(carat^3)","I(carat*depth)","I(carat^2)","I(carat)"),
#                           focus_value = list(carat=seq(0.5,6,0.1)),
#                           Data = diamonds,PRINT = T,STOP =T, Reverse = F)
# 
# test
# 
# # two focus on vars
# test = deleting_wrongsign(model = diamond_lm3 , 
#                           focus_var_raw = c('carat',"cut"), 
#                           focus_var_coeff = c("I(carat*depth)","I(carat^3)",
#                                               get_x(diamond_lm3,method="model")),
#                           focus_value = list(carat=seq(0.5,6,0.1)),
#                           Data = diamonds,PRINT = T,STOP =T)
# 
# 
# ##  negative signs
# deleting_wrongsign(model = diamond_lm3 , 
#                    focus_var_raw = c('depth',"cut"), 
#                    focus_var_coeff = c("depth"),Monoton_to_Match = -1,
#                    Data = diamonds,PRINT = T,STOP =T)
# 
# 
# deleting_wrongsign(diamond_lm, focus_var_raw = 'carat', focus_var_coeff = c("I(cara79t^3)"),Data = diamonds,PRINT = T)
# deleting_wrongsign(diamond_lm, focus_var_raw = 'carat890', focus_var_coeff = c("I(carat^3)"),Data = diamonds,PRINT = T)
# 
# 
# 
# 
# get_x(preg,"model")
# 


### Test ---------------------






